# lab1实验总结

## 练习一



## 练习二



## 练习三



## 练习四



## 练习五

根据代码中提供的函数和注释完成**print_stackframe**函数的实现，打印出和示例差不多的输出。

根据函数调用时栈帧的变化，上一个函数栈的顶部存储的是调用者ebp的地址，而ebp+4存储的是返回地址，即调用者的代码地址，返回地址之上的ebp+8存储的是可能的参数。

我们最后一行的输出为

~~~
ebp:0x00007bf8 eip:0x00007d74 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8
~~~



最后一行打印的是我们的函数开始之前最早进入堆栈的函数，即读取磁盘扇区的ELF的bootmain.c中的bootmain函数，得知此函数的ebp为0x7bf8.

## 练习六

根据mmu.h中的定义，每一个表项占8个字节，其中第2-3字节是段选择址，1-2是低十六位偏移量，7-8是高十六位偏移量，他们共同构成了中断处理代码入口。

对于两个函数的修改见代码。

其中，对于trap.c的代码的修改中，本身我想通过定义一个变量累加判断，但是总是报错，参考了提供的答案发现在某个头文件中包含了这个变量的定义，其实阅读代码关注这个细节挺难的。